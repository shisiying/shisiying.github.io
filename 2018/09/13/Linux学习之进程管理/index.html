<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="努力，奋斗！"><title>Linux学习之进程管理 | 其斤.匕禾页</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux学习之进程管理</h1><a id="logo" href="/.">其斤.匕禾页</a><p class="description">永远相信美好的事情即将发生</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="https://blog.xhzyxed.cn/2018/09/22/408基础/"><i class="fa fa-archive"> 计算机基础</i></a><a href="https://blog.xhzyxed.cn/2018/09/17/resume/"><i class="fa fa-user"> resume</i></a><a href="https://www.xhzyxed.cn/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux学习之进程管理</h1><div class="post-meta">Sep 13, 2018<span> | </span><span class="category"><a href="/categories/Linux/">Linux</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#进程"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程分类"><span class="toc-number">1.1.</span> <span class="toc-text">进程分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程属性"><span class="toc-number">1.2.</span> <span class="toc-text">进程属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#父进程和子进程"><span class="toc-number">1.3.</span> <span class="toc-text">父进程和子进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程管理"><span class="toc-number">2.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ps"><span class="toc-number">2.1.</span> <span class="toc-text">ps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实际应用"><span class="toc-number">2.1.1.</span> <span class="toc-text">实际应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prep"><span class="toc-number">2.2.</span> <span class="toc-text">prep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终止进程"><span class="toc-number">2.3.</span> <span class="toc-text">终止进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kill"><span class="toc-number">2.3.1.</span> <span class="toc-text">kill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#killall"><span class="toc-number">2.3.2.</span> <span class="toc-text">killall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pkill"><span class="toc-number">2.3.3.</span> <span class="toc-text">pkill</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#top-监视系统任务的工具"><span class="toc-number">3.</span> <span class="toc-text">top 监视系统任务的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#top-命令用法及参数；"><span class="toc-number">3.1.</span> <span class="toc-text">top 命令用法及参数；</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#top应用实例"><span class="toc-number">3.2.</span> <span class="toc-text">top应用实例</span></a></li></ol></li></ol></div></div><div class="post-content"><p>了解ps，top,kill命令的使用</p>
<a id="more"></a>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h2><p>进程一般分为交互进程、批处理进程和守护进程三类。<br>值得一提的是守护进程总是活跃的，一般是后台运行，守护进程一般是由系统在开机时通过脚本自动激活启动或超级管理用户root来启动。比如在Redhat中，我们可以定义httpd 服务器的启动脚本的运行级别，此文件位于/etc/init.d目录下，文件名是httpd，/etc/init.d/httpd 就是httpd服务器的守护程序，当把它的运行级别设置为3和5时，当系统启动时，它会跟着启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chkconfig  --level 35  httpd on</span></span><br></pre></td></tr></table></figure>
<h2 id="进程属性"><a href="#进程属性" class="headerlink" title="进程属性"></a>进程属性</h2><p>进程ID（PID)：是唯一的数值，用来区分进程；<br>父进程和父进程的ID（PPID)；<br>启动进程的用户ID（UID）和所归属的组（GID）；<br>进程状态：状态分为运行R、休眠S、僵尸Z；<br>进程执行的优先级；<br>进程所连接的终端名；<br>进程资源占用：比如占用资源大小（内存、CPU占用量）；</p>
<h2 id="父进程和子进程"><a href="#父进程和子进程" class="headerlink" title="父进程和子进程"></a>父进程和子进程</h2><p>他们的关系是管理和被管理的关系，当父进程终止时，子进程也随之而终止。但子进程终止，父进程并不一定终止。比如httpd服务器运行时，我们可以杀掉其子进程，父进程并不会因为子进程的终止而终止。<br>在进程管理中，当我们发现占用资源过多，或无法控制的进程时，应该杀死它，以保护系统的稳定安全运行；</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>对于Linux进程的管理，是通过进程管理工具实现的，比如ps、kill、pgrep等工具；</p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>ps 提供了很多的选项参数，常用的有以下几个；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">l  长格式输出；</span><br><span class="line">u  按用户名和启动时间的顺序来显示进程；</span><br><span class="line">j  用任务格式来显示进程；</span><br><span class="line">f  用树形格式来显示进程；</span><br><span class="line">a  显示所有用户的所有进程（包括其它用户）；</span><br><span class="line">x  显示无控制终端的进程；</span><br><span class="line">r  显示运行中的进程；</span><br><span class="line">ww 避免详细参数被截断；</span><br></pre></td></tr></table></figure>
<p>我们常用的选项是组合是aux 或lax，还有参数f的应用；</p>
<p>ps aux / ps lax输出的字段解释</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">USER	进程的属主；</span><br><span class="line">PID	进程的ID；</span><br><span class="line">PPID      父进程；</span><br><span class="line">%CPU	进程占用的CPU百分比；</span><br><span class="line">%MEM	占用内存的百分比；</span><br><span class="line">PRI          代表这个程序『可被执行的优先级』</span><br><span class="line">NI	   进程的NICE值，数值大，表示较少占用CPU时间；</span><br><span class="line">VSZ 进程虚拟大小；</span><br><span class="line">RSS  驻留中页的数量；</span><br><span class="line">TTY  终端ID</span><br><span class="line">STAT 进程状态</span><br><span class="line">D    不间断的睡眠(usually IO)</span><br><span class="line">R    正在运行中在队列中可过行的； </span><br><span class="line">S    处于休眠状态；</span><br><span class="line">T    停止或被追踪； </span><br><span class="line">W    进入内存交换（从内核2.6开始无效）；</span><br><span class="line">X    死掉的进程（从来没见过）；</span><br><span class="line">Z    僵尸进程；</span><br><span class="line"></span><br><span class="line">&lt;    优先级高的进程 </span><br><span class="line">N    优先级较低的进程 </span><br><span class="line">L    有些页被锁进内存； </span><br><span class="line">s    进程的领导者（在它之下有子进程）；</span><br><span class="line">l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads <span class="keyword">do</span>)</span><br><span class="line">+    位于后台的进程组；</span><br><span class="line"></span><br><span class="line">WCHAN	正在等待的进程资源；</span><br><span class="line">START     启动进程的时间；</span><br><span class="line">TIME	进程消耗CPU的时间；</span><br><span class="line">COMMAND    命令的名称和参数；</span><br></pre></td></tr></table></figure>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul>
<li><p>实例一：ps aux 最常用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ps -aux | more</span></span><br><span class="line">可以用 | 管道和 more 连接起来分页查看</span><br><span class="line">[root@localhost ~]<span class="comment"># ps -aux  &gt; ps001.txt</span></span><br><span class="line">[root@localhost ~]<span class="comment"># more ps001.txt </span></span><br><span class="line">这里是把所有进程显示出来，并输出到ps001.txt文件，然后再通过more 来分页查看</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例二：和grep 结合，提取指定程序的进程；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ps aux | grep httpd</span></span><br><span class="line">root      4187  0.0  1.3  24236 10272 ?        Ss   11:55   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4189  0.0  0.6  24368  4940 ?        S    11:55   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4190  0.0  0.6  24368  4932 ?        S    11:55   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4191  0.0  0.6  24368  4932 ?        S    11:55   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4192  0.0  0.6  24368  4932 ?        S    11:55   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4193  0.0  0.6  24368  4932 ?        S    11:55   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4194  0.0  0.6  24368  4932 ?        S    11:55   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4195  0.0  0.6  24368  4932 ?        S    11:55   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4196  0.0  0.6  24368  4932 ?        S    11:55   0:00 /usr/sbin/httpd</span><br><span class="line">root      4480  0.0  0.0   5160   708 pts/3    R+   12:20   0:00 grep httpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例二：父进和子进程的关系友好判断的例子</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ps auxf  | grep httpd</span></span><br><span class="line">root      4484  0.0  0.0   5160   704 pts/3    S+   12:21   0:00              \_ grep httpd</span><br><span class="line">root      4187  0.0  1.3  24236 10272 ?        Ss   11:55   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4189  0.0  0.6  24368  4940 ?        S    11:55   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4190  0.0  0.6  24368  4932 ?        S    11:55   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4191  0.0  0.6  24368  4932 ?        S    11:55   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4192  0.0  0.6  24368  4932 ?        S    11:55   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4193  0.0  0.6  24368  4932 ?        S    11:55   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4194  0.0  0.6  24368  4932 ?        S    11:55   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4195  0.0  0.6  24368  4932 ?        S    11:55   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4196  0.0  0.6  24368  4932 ?        S    11:55   0:00  \_ /usr/sbin/httpd</span><br><span class="line">这里用到了f参数；父与子关系一目了然；</span><br></pre></td></tr></table></figure>
<h2 id="prep"><a href="#prep" class="headerlink" title="prep"></a>prep</h2><p>pgrep 是通过程序的名字来查询进程的工具，一般是用来判断程序是否正在运行。在服务器的配置和管理中，这个工具常被应用，简单明了；<br>用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pgrep 参数选项   程序名</span></span><br></pre></td></tr></table></figure></p>
<p>常用参数<br>-l  列出程序名和进程ID；<br>-o  进程起始的ID；<br>-n  进程终止的ID；<br>举例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># pgrep -lo httpd</span></span><br><span class="line">4557 httpd</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># pgrep -ln httpd</span></span><br><span class="line">566 httpd</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># pgrep -l httpd</span></span><br><span class="line">4557 httpd</span><br><span class="line">4560 httpd</span><br><span class="line">4561 httpd</span><br><span class="line">4562 httpd</span><br><span class="line">4563 httpd</span><br><span class="line">4564 httpd</span><br><span class="line">4565 httpd</span><br><span class="line">4566 httpd</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># pgrep httpd</span></span><br><span class="line">4557</span><br><span class="line">4560</span><br><span class="line">4561</span><br><span class="line">4562</span><br><span class="line">4563</span><br><span class="line">4564</span><br><span class="line">4565</span><br><span class="line">4566</span><br></pre></td></tr></table></figure></p>
<h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><p>终止一个进程或终止一个正在运行的程序，一般是通过 kill 、killall、pkill、xkill 等进行。比如一个程序已经死掉，但又不能退出，这时就应该考虑应用这些工具。</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span>的应用是和ps 或pgrep 命令结合在一起使用的；</span><br><span class="line"><span class="built_in">kill</span> 的用法：</span><br><span class="line"><span class="built_in">kill</span> ［信号代码］   进程ID</span><br><span class="line">注：信号代码可以省略；我们常用的信号代码是 -9 ，表示强制终止；</span><br><span class="line">举例：</span><br><span class="line">[root@localhost ~]<span class="comment"># ps  auxf  |grep   httpd</span></span><br><span class="line">root      4939  0.0  0.0   5160   708 pts/3    S+   13:10   0:00              \_ grep httpd</span><br><span class="line">root      4830  0.1  1.3  24232 10272 ?        Ss   13:02   0:00 /usr/sbin/httpd</span><br><span class="line">apache    4833  0.0  0.6  24364  4932 ?        S    13:02   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4834  0.0  0.6  24364  4928 ?        S    13:02   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4835  0.0  0.6  24364  4928 ?        S    13:02   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4836  0.0  0.6  24364  4928 ?        S    13:02   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4837  0.0  0.6  24364  4928 ?        S    13:02   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4838  0.0  0.6  24364  4928 ?        S    13:02   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4839  0.0  0.6  24364  4928 ?        S    13:02   0:00  \_ /usr/sbin/httpd</span><br><span class="line">apache    4840  0.0  0.6  24364  4928 ?        S    13:02   0:00  \_ /usr/sbin/httpd</span><br><span class="line">我们查看httpd 服务器的进程；您也可以用pgrep -l httpd 来查看；</span><br><span class="line">我们看上面例子中的第二列，就是进程PID的列，其中4830是httpd服务器的父进程，从4833－4840的进程都是它4830的子进程；如果我们杀掉父进程4830的话，其下的子进程也会跟着死掉；</span><br><span class="line">[root@localhost ~]<span class="comment"># kill 4840  注：杀掉4840这个进程；</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ps -auxf  |grep  httpd  注：查看一下会有什么结果？是不是httpd服务器仍在运行？</span></span><br><span class="line">[root@localhost ~]<span class="comment"># kill 4830   注：杀掉httpd的父进程；</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ps -aux |grep httpd  注：查看httpd的其它子进程是否存在，httpd服务器是否仍在运行？</span></span><br><span class="line">对于僵尸进程，可以用<span class="built_in">kill</span> -9 来强制终止退出；</span><br><span class="line">比如一个程序已经彻底死掉，如果<span class="built_in">kill</span> 不加信号强度是没有办法退出，最好的办法就是加信号强度 -9 ，后面要接杀父进程；比如；</span><br><span class="line">[root@localhost ~]<span class="comment"># ps aux |grep gaim</span></span><br><span class="line">beinan    5031  9.0  2.3 104996 17484 ?        S    13:23   0:01 gaim</span><br><span class="line">root      5036  0.0  0.0   5160   724 pts/3    S+   13:24   0:00 grep gaim</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># pgrep -l gaim</span></span><br><span class="line">5031 gaim</span><br><span class="line">[root@localhost ~]<span class="comment"># kill -9 5031</span></span><br></pre></td></tr></table></figure>
<h3 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h3><p>killall 通过程序的名字，直接杀死所有进程，咱们简单说一下就行了。</p>
<p>用法：killall 正在运行的程序名</p>
<p>killall 也和ps或pgrep 结合使用，比较方便；通过ps或pgrep 来查看哪些程序在运行；<br>举例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost beinan]<span class="comment"># pgrep -l gaim</span></span><br><span class="line">2979 gaim</span><br><span class="line">[root@localhost beinan]<span class="comment"># killall gaim</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h3><p>pkill 和killall 应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill 来杀掉。<br>应用方法：</p>
<p>#pkill  正在运行的程序名<br>举例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@localhost beinan]<span class="comment"># pgrep -l gaim</span></span><br><span class="line">2979 gaim</span><br><span class="line"></span><br><span class="line">[root@localhost beinan]<span class="comment"># pkill gaim</span></span><br></pre></td></tr></table></figure></p>
<h1 id="top-监视系统任务的工具"><a href="#top-监视系统任务的工具" class="headerlink" title="top 监视系统任务的工具"></a>top 监视系统任务的工具</h1><p>和ps 相比，top是动态监视系统任务的工具，top 输出的结果是连续的；</p>
<h2 id="top-命令用法及参数；"><a href="#top-命令用法及参数；" class="headerlink" title="top 命令用法及参数；"></a>top 命令用法及参数；</h2><p>top 调用方法：<br>top 选择参数<br>参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b  以批量模式运行，但不能接受命令行输入；</span><br><span class="line">-c 显示命令行，而不仅仅是命令名；</span><br><span class="line">-d N  显示两次刷新时间的间隔，比如 -d 5，表示两次刷新间隔为5秒；</span><br><span class="line">-i 禁止显示空闲进程或僵尸进程；</span><br><span class="line">-n NUM  显示更新次数，然后退出。比如 -n 5，表示top更新5次数据就退出；</span><br><span class="line">-p PID 仅监视指定进程的ID；PID是一个数值；</span><br><span class="line">-q  不经任何延时就刷新；</span><br><span class="line">-s  安全模式运行，禁用一些效互指令；</span><br><span class="line">-S 累积模式，输出每个进程的总的CPU时间，包括已死的子进程；</span><br></pre></td></tr></table></figure></p>
<p>交互式命令键位：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">space  立即更新；</span><br><span class="line">c 切换到命令名显示，或显示整个命令（包括参数）；</span><br><span class="line">f,F 增加显示字段，或删除显示字段；</span><br><span class="line">h,? 显示有关安全模式及累积模式的帮助信息；</span><br><span class="line">k 提示输入要杀死的进程ID，目的是用来杀死该进程（默人信号为15）</span><br><span class="line">i 禁止空闲进程和僵尸进程；</span><br><span class="line">l 切换到显法负载平均值和正常运行的时间等信息；</span><br><span class="line">m 切换到内存信息，并以内存占用大小排序；</span><br><span class="line">n  提示显示的进程数，比如输入3，就在整屏上显示3个进程；</span><br><span class="line">o,O 改变显示字段的顺序；</span><br><span class="line">r 把renice 应用到一个进程，提示输入PID和renice的值；</span><br><span class="line">s 改变两次刷新时间间隔，以秒为单位；</span><br><span class="line">t 切换到显示进程和CPU状态的信息；</span><br><span class="line">A 按进程生命大小进行排序，最新进程显示在最前；</span><br><span class="line">M 按内存占用大小排序，由大到小；</span><br><span class="line">N 以进程ID大小排序，由大到小；</span><br><span class="line">P 按CPU占用情况排序，由大到小</span><br><span class="line">S 切换到累积时间模式；</span><br><span class="line">T  按时间／累积时间对任务排序；</span><br><span class="line">W 把当前的配置写到~/.toprc中；</span><br></pre></td></tr></table></figure></p>
<h2 id="top应用实例"><a href="#top应用实例" class="headerlink" title="top应用实例"></a>top应用实例</h2><p><img src="top.png" alt=""></p>
<ul>
<li><p>第一行：<br>10:01:23 — 当前系统时间<br>126 days, 14:29 — 系统已经运行了126天14小时29分钟（在这期间没有重启过）<br>2 users — 当前有2个用户登录系统<br>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。<br>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p>
</li>
<li><p>第二行：<br>Tasks — 任务（进程），系统现在共有183个进程，其中处于运行中的有1个，182个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
</li>
<li><p>第三行：cpu状态<br>6.7% us — 用户空间占用CPU的百分比。<br>0.4% sy — 内核空间占用CPU的百分比。<br>0.0% ni — 改变过优先级的进程占用CPU的百分比<br>92.9% id — 空闲CPU百分比<br>0.0% wa — IO等待占用CPU的百分比<br>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比<br>0.0% si — 软中断（Software Interrupts）占用CPU的百分比<br>在这里CPU的使用比率和windows概念不同，如果你不理解用户空间和内核空间，需要充充电了。</p>
</li>
<li><p>第四行：内存状态<br>8306544k total — 物理内存总量（8GB）<br>7775876k used — 使用中的内存总量（7.7GB）<br>530668k free — 空闲内存总量（530M）<br>79236k buffers — 缓存的内存量 （79M）</p>
</li>
<li><p>第五行：swap交换分区<br>2031608k total — 交换区总量（2GB）<br>2556k used — 使用的交换区总量（2.5M）<br>2029052k free — 空闲交换区总量（2GB）<br>4231276k cached — 缓冲的交换区总量（4GB）<br>这里要说明的是不能用windows的内存概念理解这些数据，如果按windows的方式此台服务器“危矣”：8G的内存总量只剩下530M的可用内存。Linux的内存管理有其特殊性，复杂点需要一本书来说明，这里只是简单说点和我们传统概念（windows）的不同。<br>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。<br>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存：530668+79236+4231276 = 4.7GB。<br>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p>
</li>
<li><p>第六行是空行</p>
</li>
<li><p>第七行以下：各进程（任务）的状态监控</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PID — 进程id</span><br><span class="line">USER — 进程所有者</span><br><span class="line">PR — 进程优先级</span><br><span class="line">NI — nice值。负值表示高优先级，正值表示低优先级</span><br><span class="line">VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class="line">RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class="line">SHR — 共享内存大小，单位kb</span><br><span class="line">S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class="line">%CPU — 上次更新到现在的CPU时间占用百分比</span><br><span class="line">%MEM — 进程使用的物理内存百分比</span><br><span class="line">TIME+ — 进程使用的CPU时间总计，单位1/100秒</span><br><span class="line">COMMAND — 进程名称（命令名/命令行）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/09/14/php核心学习-设计模式的学习-单例模式/">php核心学习-设计模式的学习-单例模式</a><a class="next" href="/2018/09/13/Linux学习之服务与进程管理/">Linux学习之服务与进程管理</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.xhzyxed.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/408/">408</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vuejs/">vuejs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web安全/">web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端构建工具/">前端构建工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/推文/">推文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目/">项目</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/mysql优化之学习explain分析sql语句/">mysql优化之学习explain分析sql语句</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/mysql优化之索引学习脑图/">mysql优化之索引学习脑图</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/mysql优化之重复索引，冗余索引以及索引碎片/">mysql优化之重复索引，冗余索引以及索引碎片</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/mysql优化之大数据量分页优化/">mysql优化之大数据量分页优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/mysql优化之索引长度/">mysql优化之索引长度</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/26/mysql优化之聚簇索引/">mysql优化之聚簇索引</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/24/mysql优化之btree索引/">mysql优化之btree索引</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/24/mysql优化之类型的选择/">mysql优化之类型的选择</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/24/mysql优化之mysql进程状态/">mysql优化之mysql进程状态</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/24/mysql优化之mysql-status的周期变化/">mysql优化之mysql status的周期变化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://org.xhzyxed.cn/" title="小猴子与小耳朵" target="_blank">小猴子与小耳朵</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">其斤.匕禾页.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>